<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Teste de Transposi√ß√£o em Setlist</title>
  <script src="https://unpkg.com/chord-transposer@1.0.0/dist/chord-transposer.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    .test-case {
      background: white;
      padding: 20px;
      margin: 20px 0;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .cifra {
      background: #f8f9fa;
      padding: 15px;
      border-radius: 5px;
      white-space: pre-wrap;
      font-family: monospace;
      border: 1px solid #dee2e6;
    }
    .chord {
      color: #007bff;
      font-weight: bold;
    }
    .error {
      color: #dc3545;
      background: #f8d7da;
      padding: 10px;
      border-radius: 5px;
      margin: 10px 0;
    }
    .success {
      color: #155724;
      background: #d4edda;
      padding: 10px;
      border-radius: 5px;
      margin: 10px 0;
    }
    h1 { color: #333; }
    h2 { color: #666; }
    h3 { color: #888; }
    .test-info {
      background: #e3f2fd;
      padding: 10px;
      border-radius: 5px;
      margin: 10px 0;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <h1>üß™ Teste de Transposi√ß√£o em Setlist</h1>
  <p>Este teste simula o ambiente de transposi√ß√£o usado na p√°gina setlist-view.html</p>
  
  <div id="resultado"></div>

  <script>
    // Copiar a fun√ß√£o exata da setlist-view.html (vers√£o corrigida)
    function manualTranspose(cifra, fromKey, toKey) {
      console.log(`üõ†Ô∏è Transposi√ß√£o manual: ${fromKey} ‚Üí ${toKey}`);
      
      // Normalizar as chaves de entrada (remover sufixos como m, 7, etc.)
      const normalizeKey = (key) => {
        if (!key) return 'C';
        const cleanKey = key.replace(/[^A-G#b]/g, '').toUpperCase();
        // Converter bem√≥is para sustenidos para padroniza√ß√£o
        const keyMap = {
          'DB': 'C#', 'EB': 'D#', 'GB': 'F#', 'AB': 'G#', 'BB': 'A#'
        };
        return keyMap[cleanKey] || cleanKey;
      };

      const normalizedFrom = normalizeKey(fromKey);
      const normalizedTo = normalizeKey(toKey);
      
      console.log(`   Chaves normalizadas: ${fromKey} ‚Üí ${normalizedFrom}, ${toKey} ‚Üí ${normalizedTo}`);
      
      const keys = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
      const fromIndex = keys.indexOf(normalizedFrom);
      const toIndex = keys.indexOf(normalizedTo);
      
      if (fromIndex === -1 || toIndex === -1) {
        console.warn(`‚ö†Ô∏è Chaves inv√°lidas para transposi√ß√£o manual: ${normalizedFrom} ou ${normalizedTo}`);
        return cifra;
      }
      
      // Calcular steps considerando o caminho mais curto
      let steps = toIndex - fromIndex;
      if (steps > 6) steps -= 12;
      if (steps < -6) steps += 12;
      
      console.log(`   Steps manuais: ${steps} (${normalizedFrom}[${fromIndex}] ‚Üí ${normalizedTo}[${toIndex}])`);
      
      // Se n√£o h√° transposi√ß√£o necess√°ria
      if (steps === 0) {
        console.log(`   ‚èπÔ∏è Nenhuma transposi√ß√£o necess√°ria`);
        return cifra;
      }
      
      // Criar mapa de transposi√ß√£o robusto
      const transposeMap = new Map();
      
      // Mapeamento direto das 12 notas
      keys.forEach((note, index) => {
        let newIndex = (index + steps) % 12;
        if (newIndex < 0) newIndex += 12;
        transposeMap.set(note, keys[newIndex]);
      });
      
      // Adicionar mapeamentos enarm√¥nicos
      const enharmonics = [
        ['C#', 'Db'], ['D#', 'Eb'], ['F#', 'Gb'], ['G#', 'Ab'], ['A#', 'Bb']
      ];
      
      enharmonics.forEach(([sharp, flat]) => {
        if (transposeMap.has(sharp)) {
          transposeMap.set(flat, transposeMap.get(sharp));
        }
        if (transposeMap.has(flat)) {
          transposeMap.set(sharp, transposeMap.get(flat));
        }
      });
      
      console.log('   Mapa de transposi√ß√£o:', Object.fromEntries(transposeMap));
      
      // Fun√ß√£o para transpor um acorde individual
      function transposeChord(chord) {
        console.log(`     Processando acorde: "${chord}"`);
        
        // Tratar acordes com baixo (ex: C/E)
        if (chord.includes('/')) {
          const [mainChord, bassNote] = chord.split('/');
          const transposedMain = transposeChord(mainChord.trim());
          const transposedBass = transposeChord(bassNote.trim());
          const result = `${transposedMain}/${transposedBass}`;
          console.log(`     Acorde com baixo: ${chord} ‚Üí ${result}`);
          return result;
        }
        
        // Extrair a nota raiz usando regex mais espec√≠fica
        const rootMatch = chord.match(/^([A-G](?:#|b)?)/i);
        if (!rootMatch) {
          console.log(`     N√£o √© um acorde reconhecido: ${chord}`);
          return chord;
        }
        
        const root = rootMatch[1].toUpperCase();
        const suffix = chord.substring(rootMatch[1].length);
        
        // Buscar a transposi√ß√£o da raiz
        const newRoot = transposeMap.get(root);
        
        if (!newRoot) {
          console.warn(`     ‚ö†Ô∏è N√£o foi poss√≠vel transpor a raiz: ${root}`);
          return chord;
        }
        
        // Verificar se o resultado seria um acorde inv√°lido
        const invalidChords = ['C##', 'D##', 'E#', 'F##', 'G##', 'A##', 'B#', 'Cb', 'Dbb', 'Ebb', 'Fb', 'Gbb', 'Abb', 'Bbb'];
        const tentativeResult = newRoot + suffix;
        
        if (invalidChords.some(invalid => tentativeResult.startsWith(invalid))) {
          console.warn(`     ‚ö†Ô∏è Acorde inv√°lido detectado: ${tentativeResult}, mantendo original: ${chord}`);
          return chord;
        }
        
        const result = tentativeResult;
        console.log(`     ${chord} ‚Üí ${result}`);
        return result;
      }
      
      // Aplicar transposi√ß√£o na cifra com regex melhorada
      const chordRegex = /\b([A-G](?:#|b)?(?:m|maj|min|dim|aug|sus|add|\d)*(?:\/[A-G](?:#|b)?)?)\b/gi;
      
      const transposed = cifra.replace(chordRegex, (match, chord) => {
        // Verificar se √© realmente um acorde v√°lido
        const cleanMatch = match.trim();
        
        // Ignorar vogais isoladas e palavras comuns
        if (cleanMatch.length === 1 && /^[AaEeIiOoUu]$/.test(cleanMatch)) {
          return match;
        }
        
        // Ignorar palavras muito comuns que podem ter letras de acordes
        const commonWords = ['a', 'e', 'o', 'da', 'de', 'do', 'em', 'um', 'uma', 'para', 'com', 'se', 'que'];
        if (commonWords.includes(cleanMatch.toLowerCase())) {
          return match;
        }
        
        return transposeChord(cleanMatch);
      });
      
      console.log(`‚úÖ Transposi√ß√£o manual conclu√≠da`);
      return transposed;
    }

    function transposeCifra(cifra, fromKey, toKey) {
      console.log(`üîÑ transposeCifra chamada: "${fromKey}" ‚Üí "${toKey}"`);
      console.log(`   Cifra original: "${cifra.substring(0, 50)}..."`);
      
      if (!fromKey || !toKey || fromKey === toKey) {
        console.log(`   ‚èπÔ∏è Transposi√ß√£o desnecess√°ria (${fromKey} === ${toKey})`);
        return cifra;
      }

      try {
        if (typeof ChordTransposer !== 'undefined') {
          console.log(`   ‚úÖ ChordTransposer dispon√≠vel, tentando usar...`);
          
          const keys = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
          const fromIndex = keys.indexOf(fromKey.toUpperCase());
          const toIndex = keys.indexOf(toKey.toUpperCase());
          
          console.log(`   √çndices: ${fromKey}(${fromIndex}) ‚Üí ${toKey}(${toIndex})`);
          
          if (fromIndex !== -1 && toIndex !== -1) {
            let steps = toIndex - fromIndex;
            if (steps < 0) steps += 12;
            
            console.log(`   Steps para transposi√ß√£o: ${steps}`);
            
            // M√©todo direto
            const transposed = ChordTransposer.transpose(cifra).up(steps).toString();
            console.log(`   ‚úÖ Transposi√ß√£o ChordTransposer realizada`);
            
            return transposed;
          } else {
            console.warn(`   ‚ö†Ô∏è Chaves n√£o reconhecidas: ${fromKey}(${fromIndex}) ou ${toKey}(${toIndex})`);
          }
        } else {
          console.warn(`   ‚ö†Ô∏è ChordTransposer n√£o dispon√≠vel, usando transposi√ß√£o manual`);
        }
      } catch (error) {
        console.error('‚ùå Erro no ChordTransposer, usando transposi√ß√£o manual:', error);
      }
      
      // Fallback: transposi√ß√£o manual
      return manualTranspose(cifra, fromKey, toKey);
    }

    function highlightChords(text) {
      const chordRegex = /\b([A-G](?:#|b)?(?:m|maj|min|dim|aug|sus|add|\d)*(?:\/[A-G](?:#|b)?)?)\b/gi;
      return text.replace(chordRegex, '<span class="chord">$1</span>');
    }

    function verificarAcordesInvalidos(cifra) {
      const invalidChords = ['C##', 'D##', 'E#', 'F##', 'G##', 'A##', 'B#', 'Cb', 'Dbb', 'Ebb', 'Fb', 'Gbb', 'Abb', 'Bbb'];
      const encontrados = [];
      
      invalidChords.forEach(invalid => {
        if (cifra.includes(invalid)) {
          encontrados.push(invalid);
        }
      });
      
      return encontrados;
    }

    function executarTestes() {
      console.log('üß™ Iniciando testes de transposi√ß√£o...');
      
      const testCases = [
        {
          name: "Caso do Problema Reportado: D# para D",
          fromKey: "D#",
          toKey: "D",
          cifra: `Estrofe:
D#         Bm         D#          Bm
Ponte:
D/F#       F#         D#          G#
Refr√£o:
F#         D#         Bm          G#
D/F#       F#         Bm          G#         F#         Bm         G#`
        },
        {
          name: "Transposi√ß√µes Extremas: F# para F",
          fromKey: "F#",
          toKey: "F",
          cifra: `F#         C#         D#m        A#m
Gb         Db         Ebm        Bbm`
        },
        {
          name: "Acordes com Baixo: C para D",
          fromKey: "C",
          toKey: "D",
          cifra: `C/E        F/A        G/B        Am/C
D/F#       G/D        A/C#       Bm/D`
        },
        {
          name: "Tons Bem√≥is para Sustenidos: Bb para A#",
          fromKey: "Bb",
          toKey: "A#",
          cifra: `Bb         Eb         F          Cm
Ab         Db         Bb/D       Eb`
        },
        {
          name: "Transposi√ß√£o Normal: C para G",
          fromKey: "C",
          toKey: "G",
          cifra: `C          F          G          Am
Dm         G          C          C7`
        }
      ];
      
      const resultado = document.getElementById('resultado');
      let html = '';
      
      testCases.forEach((test, index) => {
        console.log(`\n--- Teste ${index + 1}: ${test.name} ---`);
        
        const transposed = transposeCifra(test.cifra, test.fromKey, test.toKey);
        const invalidFound = verificarAcordesInvalidos(transposed);
        
        html += `
          <div class="test-case">
            <h2>Teste ${index + 1}: ${test.name}</h2>
            <div class="test-info">
              <strong>Transposi√ß√£o:</strong> ${test.fromKey} ‚Üí ${test.toKey}
            </div>
            
            <h3>Original (${test.fromKey}):</h3>
            <div class="cifra">${highlightChords(test.cifra)}</div>
            
            <h3>Transposto (${test.toKey}):</h3>
            <div class="cifra">${highlightChords(transposed)}</div>
            
            ${invalidFound.length > 0 ? 
              `<div class="error">‚ö†Ô∏è <strong>Acordes inv√°lidos encontrados:</strong> ${invalidFound.join(', ')}</div>` :
              `<div class="success">‚úÖ <strong>Nenhum acorde inv√°lido encontrado!</strong></div>`
            }
          </div>
        `;
      });
      
      resultado.innerHTML = html;
      console.log('‚úÖ Todos os testes conclu√≠dos!');
    }

    // Aguardar ChordTransposer carregar e executar testes
    setTimeout(executarTestes, 1000);
  </script>
</body>
</html>
